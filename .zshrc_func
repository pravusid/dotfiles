RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m'

funcs() {
  cat ~/.zshrc_func | grep '^#@'
}

#@ mpeg-dn <input> <output>
mpeg-dn() {
  ffmpeg -i "$1" -c copy -bsf:a aac_adtstoasc "$2"
}

#@ port-scan <host> <port>
port-scan() {
  HOST=$1
  PORT=$2
  echo -e "${YELLOW}nc -z -v $HOST $PORT${NC}"
  nc -z -v $HOST $PORT
}

#@ port-kill <port> -- (alternative) fuser -k <port>/tcp
port-kill() {
  lsof -ti :$1 | xargs -r -I {} kill -9 {}
  echo "${RED}kill port $1${NC}"
}

# https://pravusid.kr/wiki/Docker/docker-volume.html

#@ docker-vol ls
#@ docker-vol clean
docker-vol() {
  if [[ $1 == "ls" ]]; then
    docker ps -a --format '{{ .ID }}' |
      xargs -I {} docker inspect -f '{{ .Name }}{{ range .Mounts }}{{ printf "\n\t" }}{{ .Type }} {{ if eq .Type "bind" }}{{ .Source }}{{ end }}{{ .Name }} => {{ .Destination }}{{ end }}{{ printf "\n" }}' {}
  elif [[ $1 == "clean" ]]; then
    # docker volume ls -qf dangling=true | xargs -r docker volume rm
    # https://docs.docker.com/reference/cli/docker/volume/prune/
    docker volume prune
  else
    echo "unknown command"
  fi
}

#@ docker-img clean
docker-img() {
  if [[ $1 == "clean" ]]; then
    # docker images -qf dangling=true | xargs docker rmi
    # https://docs.docker.com/reference/cli/docker/image/prune/
    docker image prune
  else
    echo "unknown command"
  fi
}

#@ fd-nm -- 하위경로의 node_modules 디렉토리 검색
fd-nm() {
  if [[ -x "$(command -v fd)" ]]; then
    echo -e "${YELLOW}fd -H -I -t d --prune \"node_modules\"${NC}"
    fd -H -I -t d --prune "node_modules"
  else
    echo -e "${YELLOW}find . -name \"node_modules\" -type d -prune${NC}"
    find . -name 'node_modules' -type d -prune
  fi
}

# https://help.dropbox.com/sync/ignored-files

#@ dropbox-ignore <path>
dropbox-ignore() {
  if [[ $(uname) == "Linux" ]]; then
    attr -s com.dropbox.ignored -V 1 $1
  elif [[ $(uname) == "Darwin" ]]; then
    xattr -w "com.apple.fileprovider.ignore#P" 1 $1
  fi
}

#@ dropbox-unignore <path>
dropbox-unignore() {
  if [[ $(uname) == "Linux" ]]; then
    attr -r com.dropbox.ignored $1
  elif [[ $(uname) == "Darwin" ]]; then
    xattr -d "com.apple.fileprovider.ignore#P" $1
  fi
}

#@ du-sorted -- 현재경로의 파일 용량순서대로 출력
du-sorted() {
  echo -e "${YELLOW}du -kh -d0 * 2> /dev/null | sort -rh${NC}"
  du -kh -d0 * 2> /dev/null | sort -rh
}

#@ du-dir-sorted -- 현재경로의 디렉토리 용량순서대로 출력
du-dir-sorted() {
  echo -e "${YELLOW}du -kh -d1 2> /dev/null | sort -rh${NC}"
  du -kh -d1 2> /dev/null | sort -rh
}

#@ jless <path> -- jq & less
jless() {
  jq -C -R '. as $raw | try fromjson catch $raw' $1 | less -R
}

# man zshexpn → ${~var}

#@ count-files [glob] -- 파일 수 출력
count-files() {
  glob=${1:-.}
  ls -1A ${~glob} | wc -l | tr -s " "
}

#@ count-lines [glob] -- 파일별 라인수 출력
count-lines() {
  glob=${1:-*}
  for f in ${~glob}; do echo ${f} $(rg -c . $f); done;
}

#@ convert-eol -- \r\n to \n
convert-eol() {
  find | xargs perl -pi -e 's/\r\n/\n/g'
}

#@ rm-empty-dir -- 현재 경로의 비어있는 디렉토리 삭제
rm-empty-dir() {
  find . -empty -type d -delete -print
}

#@ fzfpv -- 현재경로 파일 미리보기 (fzf + bat)
fzfpv() {
  fzf --preview "bat --color=always --style=numbers --line-range=:500 {}" \
    --bind shift-left:preview-page-up,shift-right:preview-page-down \
    --preview-window 70%,border-double,top
}

#@ read-pkcs12 -- p12 인증서 내용확인 (openssl)
read-pkcs12() {
  file="$(fzf)" && read -s passwd && openssl pkcs12 -info -provider legacy -provider default -in "$file" -nodes -clcerts -passin pass:"$passwd"
}

#@ cp949 -- cp949 to utf8 -- iconv -c -f cp949 -t utf-8
cp949() {
  iconv -c -f cp949 -t utf-8 $1
}

#@ calc-sum -- stdin 내의 숫자 합계, 공백 또는 개행으로 구분, pipe 가능
calc-sum() {
  { [ $# -gt 0 ] && echo "$*" || cat; } | tr -s '[:space:]' '+' | sed 's/+$//' | bc
}

# keychain-environment-variable https://gist.github.com/bmhatfield/f613c10e360b4f27033761bbee4404fd

#@ keychain-env-get SECRET_ENV_KEY
keychain-env-get () {
  security find-generic-password -w -a ${USER} -D "environment variable" -s "${1}"
}

#@ keychain-env-set SECRET_ENV_KEY
keychain-env-set () {
  [ -n "$1" ] || { echo "환경변수 이름이 필요합니다"; return 1; }

  # Note: if using bash, use `-p` to indicate a prompt string, rather than the leading `?`
  read -s "?Enter Value for ${1}: " secret

  ( [ -n "$1" ] && [ -n "$secret" ] ) || return 1
  security add-generic-password -U -a ${USER} -D "environment variable" -s "${1}" -w "${secret}"
  echo "키체인에 ${1}이 저장되었습니다"
}

#@ keychain-env-del SECRET_ENV_KEY
keychain-env-del() {
  [ -n "$1" ] || { echo "환경변수 이름이 필요합니다"; return 1; }

  echo -n "키체인에서 ${1}을(를) 삭제하시겠습니까? [y/N]: "
  read confirm
  if [[ "$confirm" != [yY] ]]; then
    echo "삭제를 취소했습니다."
    return 0
  fi

  security delete-generic-password -a ${USER} -D "environment variable" -s "${1}" 2>/dev/null
  echo "키체인에서 ${1}이 삭제되었습니다"
}
