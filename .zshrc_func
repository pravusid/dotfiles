RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m'

funcs() {
  cat ~/.zshrc_func | grep '^#@'
}

#@ test-shell
test-shell() {
  for i in {1..10}; do /usr/bin/time $SHELL -i -c exit; done
}

#@ mpeg-dn <input> <output>
mpeg-dn() {
  ffmpeg -i "$1" -c copy -bsf:a aac_adtstoasc "$2"
}

#@ port-scan <host> <port>
port-scan() {
  HOST=$1
  PORT=$2
  echo -e "${YELLOW}nc -z -v $HOST $PORT${NC}"
  nc -z -v $HOST $PORT
}

#@ port-kill <port> -- (alternative) fuser -k <port>/tcp
port-kill() {
  lsof -ti :$1 | xargs -r -I {} kill -9 {}
  echo "${RED}kill port $1${NC}"
}

# https://pravusid.kr/wiki/Docker/docker-volume.html

#@ docker-vol ls
#@ docker-vol clean
docker-vol() {
  if [[ $1 == "ls" ]]; then
    docker ps -a --format '{{ .ID }}' |
      xargs -I {} docker inspect -f '{{ .Name }}{{ range .Mounts }}{{ printf "\n\t" }}{{ .Type }} {{ if eq .Type "bind" }}{{ .Source }}{{ end }}{{ .Name }} => {{ .Destination }}{{ end }}{{ printf "\n" }}' {}
  elif [[ $1 == "clean" ]]; then
    # docker volume ls -qf dangling=true | xargs -r docker volume rm
    # https://docs.docker.com/reference/cli/docker/volume/prune/
    docker volume prune
  else
    echo "unknown command"
  fi
}

#@ docker-img clean
docker-img() {
  if [[ $1 == "clean" ]]; then
    # docker images -qf dangling=true | xargs docker rmi
    # https://docs.docker.com/reference/cli/docker/image/prune/
    docker image prune
  else
    echo "unknown command"
  fi
}

#@ fd-nm -- í•˜ìœ„ê²½ë¡œì˜ node_modules ë””ë ‰í† ë¦¬ ê²€ìƒ‰
fd-nm() {
  if [[ -x "$(command -v fd)" ]]; then
    echo -e "${YELLOW}fd -H -I -t d --prune \"node_modules\"${NC}"
    fd -H -I -t d --prune "node_modules"
  else
    echo -e "${YELLOW}find . -name \"node_modules\" -type d -prune${NC}"
    find . -name 'node_modules' -type d -prune
  fi
}

# https://help.dropbox.com/sync/ignored-files

#@ dropbox-ignore <path>
dropbox-ignore() {
  if [[ $(uname) == "Linux" ]]; then
    attr -s com.dropbox.ignored -V 1 $1
  elif [[ $(uname) == "Darwin" ]]; then
    xattr -w "com.apple.fileprovider.ignore#P" 1 $1
  fi
}

#@ dropbox-unignore <path>
dropbox-unignore() {
  if [[ $(uname) == "Linux" ]]; then
    attr -r com.dropbox.ignored $1
  elif [[ $(uname) == "Darwin" ]]; then
    xattr -d "com.apple.fileprovider.ignore#P" $1
  fi
}

#@ du-sorted -- í˜„ì¬ê²½ë¡œì˜ íŒŒì¼ ìš©ëŸ‰ìˆœì„œëŒ€ë¡œ ì¶œë ¥
du-sorted() {
  echo -e "${YELLOW}du -kh -d0 * 2> /dev/null | sort -rh${NC}"
  du -kh -d0 * 2> /dev/null | sort -rh
}

#@ du-dir-sorted -- í˜„ì¬ê²½ë¡œì˜ ë””ë ‰í† ë¦¬ ìš©ëŸ‰ìˆœì„œëŒ€ë¡œ ì¶œë ¥
du-dir-sorted() {
  echo -e "${YELLOW}du -kh -d1 2> /dev/null | sort -rh${NC}"
  du -kh -d1 2> /dev/null | sort -rh
}

#@ jless <path> -- jq & less
jless() {
  jq -C -R '. as $raw | try fromjson catch $raw' $1 | less -R
}

# man zshexpn â†’ ${~var}

#@ count-files [glob] -- íŒŒì¼ ìˆ˜ ì¶œë ¥
count-files() {
  glob=${1:-.}
  ls -1A ${~glob} | wc -l | tr -s " "
}

#@ count-lines [glob] -- íŒŒì¼ë³„ ë¼ì¸ìˆ˜ ì¶œë ¥
count-lines() {
  glob=${1:-*}
  for f in ${~glob}; do echo ${f} $(rg -c . $f); done;
}

#@ convert-eol -- \r\n to \n
convert-eol() {
  find | xargs perl -pi -e 's/\r\n/\n/g'
}

#@ rm-empty-dir -- í˜„ì¬ ê²½ë¡œì˜ ë¹„ì–´ìˆëŠ” ë””ë ‰í† ë¦¬ ì‚­ì œ
rm-empty-dir() {
  find . -empty -type d -delete -print
}

#@ fzfpv -- í˜„ì¬ê²½ë¡œ íŒŒì¼ ë¯¸ë¦¬ë³´ê¸° (fzf + bat)
fzfpv() {
  fzf --preview "bat --color=always --style=numbers --line-range=:500 {}" \
    --bind shift-left:preview-page-up,shift-right:preview-page-down \
    --preview-window 70%,border-double,top
}

#@ read-pkcs12 -- p12 ì¸ì¦ì„œ ë‚´ìš©í™•ì¸ (openssl)
read-pkcs12() {
  file="$(fzf)" && read -s passwd && openssl pkcs12 -info -provider legacy -provider default -in "$file" -nodes -clcerts -passin pass:"$passwd"
}

#@ cp949 -- cp949 to utf8 -- iconv -c -f cp949 -t utf-8
cp949() {
  iconv -c -f cp949 -t utf-8 $1
}

#@ calc-sum -- stdin ë‚´ì˜ ìˆ«ì í•©ê³„, ê³µë°± ë˜ëŠ” ê°œí–‰ìœ¼ë¡œ êµ¬ë¶„, pipe ê°€ëŠ¥
calc-sum() {
  { [ $# -gt 0 ] && echo "$*" || cat; } | tr -s '[:space:]' '+' | sed 's/+$//' | bc
}

# keychain-environment-variable https://gist.github.com/bmhatfield/f613c10e360b4f27033761bbee4404fd

#@ keychain-env-get SECRET_ENV_KEY
keychain-env-get () {
  security find-generic-password -w -a ${USER} -D "environment variable" -s "${1}"
}

#@ keychain-env-set SECRET_ENV_KEY
keychain-env-set () {
  [ -n "$1" ] || { echo "í™˜ê²½ë³€ìˆ˜ ì´ë¦„ì´ í•„ìš”í•©ë‹ˆë‹¤"; return 1; }

  # Note: if using bash, use `-p` to indicate a prompt string, rather than the leading `?`
  read -s "?Enter Value for ${1}: " secret

  ( [ -n "$1" ] && [ -n "$secret" ] ) || return 1
  security add-generic-password -U -a ${USER} -D "environment variable" -s "${1}" -w "${secret}"
  echo "í‚¤ì²´ì¸ì— ${1}ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤"
}

#@ keychain-env-del SECRET_ENV_KEY
keychain-env-del() {
  [ -n "$1" ] || { echo "í™˜ê²½ë³€ìˆ˜ ì´ë¦„ì´ í•„ìš”í•©ë‹ˆë‹¤"; return 1; }

  echo -n "í‚¤ì²´ì¸ì—ì„œ ${1}ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? [y/N]: "
  read confirm
  if [[ "$confirm" != [yY] ]]; then
    echo "ì‚­ì œë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤."
    return 0
  fi

  security delete-generic-password -a ${USER} -D "environment variable" -s "${1}" 2>/dev/null
  echo "í‚¤ì²´ì¸ì—ì„œ ${1}ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤"
}

_exec_agent() {
  local prompt="$1"
  shift

  local agent=""
  local query=""

  if [[ "$1" == "--claude" ]] || [[ "$1" == "--gpt" ]] || [[ "$1" == "--gemini" ]]; then
    agent="${1#--}" # -- ì œê±°
    shift
    query="$*"
  else
    agent="$DEFAULT_AGENT"
    query="$*"
  fi

  # pipe ì…ë ¥ ì²˜ë¦¬
  if [ ! -t 0 ]; then
    if [[ -n "$query" ]]; then
      prompt+=$'\n'${query}
    fi
    query=$(cat)
  fi

  local input="
  <instruction>${prompt}</instruction>
  <query>${query}</query>
  "

  if [[ "$agent" == "claude" ]]; then
    claude --model haiku -p "$input"
  elif [[ "$agent" == "gpt" ]]; then
    codex -c model="gpt-5-codex" -c sandbox_mode="read-only" -c model_reasoning_effort="low" -c model_verbosity="low" \
      exec --skip-git-repo-check "$input"
  elif [[ "$agent" == "gemini" ]]; then
    gemini -m gemini-2.5-flash --sandbox -p "$input"
  fi
}

#@ q <arg|pipe> - ê°œë°œ ê´€ë ¨ ë‹¨ìˆœ ì§ˆì˜
q() {
  local prompt="
  You are a software development assistant that responds in Korean.
  The user wants fast, executable answers with verification links. Follow this format strictly.

  ## Output Format
  - TL;DR: 3â€“5 lines of core, immediately actionable points.
  - Snippet/Steps: Copy-pastable minimal example (include install/import).
  - Verification Links: 1â€“3 links, official docs first (optionally 1 auxiliary).
  - Caveats/Tips: 1â€“3 common pitfalls or version/env differences.
  - Assumptions: State reasonable defaults for ambiguities (e.g., Next.js 14, React 18, Node LTS).

  ## Style Rules
  - No fluff; be factual and concise. Provide one recommended approach + at most one alternative.
  - For errors: Cause â†’ Fix in 1â€“2 lines.
  - If performance/security implications exist: add one line.
  - If anything is uncertain, prefix with **Uncertain:** and provide how to verify (commands/links).

  ## Link Policy
  Prefer the latest stable official documentation (include version when possible).
  "
  _exec_agent "$prompt" "$@"
}

#@ doc <arg|pipe> - ê³µì‹ë¬¸ì„œ ê²€ìƒ‰
doc() {
  local prompt="
  USE context7 to get documentation for <query /> â€” if official documentation links exist, include them in the answer
  "
  _exec_agent "$prompt" "$@"
}

#@ translate <arg|pipe> - í•œêµ­ì–´ğŸ”„ì˜ì–´
translate() {
  local prompt="
  You are a bilingual translator between English and Korean.
  - The input text to translate is located within <query></query> tags
  - Detect the input language automatically
  - If English, translate to Korean
  - If Korean, translate to English
  - Preserve original formatting, structure and sentences
  - Remove unnecessary punctuation
  - Output only the translation
  "
  _exec_agent "$prompt" "$@"
}
